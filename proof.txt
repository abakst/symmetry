=============
# Soundness Proof
=============

Definition: race freedom.

Lemma:
  Let P,Γ,Δ,Ψ ~~> P',Γ',Δ',Ψ'.
  If P : race-free then P' : race-free.
Proof:
  By induction on the derivation of ~~>, splitting cases on the last step.
  (see ./race-free.txt)

Definition: Left mover.
  s is a left mover if
  ∀ σ,μ,σ',μ',p,q,s,t, p != q ->
        <σ,μ, p:t; q:s> ~~> <σ',μ',skip>
     -> <σ,μ, q:s; p:t> ~~> <σ',μ',skip>

Prop (1): "Send is a left mover"

Prop (2): "An enabled RecvFrom is a left mover"
  ∀ σ,μ,σ',μ',r,p,q,s,
       r != q
    -> ∃ m M, μ(p,q) = m · M
    -> <σ,μ,q: r:s; q:x:=recvFrom(p)> ~~> <σ',μ',skip>
    -> <σ,μ,q: q:x:=recvFrom(p); r:s> ~~> <σ',μ',skip>

=============
## Main Theorem
=============
Lemma:
 If P,Γ,Δ,Ψ ~~> P',Γ',Δ',Ψ' then,
   ∀ σ,μ,P0,P1,P0',Q,Q',E,
      P ≡ P0;P1 | Q 
   => P ≡ P0';P1 | Q'
   => Δ;(E | (P0;P1 | Q) | [[Ψ]]) : race-free   -
   => (     <⊥, [[Γ]], Δ;(E | P0;P1 | Q | [[Ψ]])>      --->* <σ,μ,skip>
        <-> <⊥, [[Γ']], Δ';(E | P0';P1 | Q' | [[Ψ']])> --->* <σ,μ,skip> ).

 Where [[Γ]] = "message buffers in Γ"
       [[Ψ]] = "parallel composition of domain of Ψ"

## Proof

Proof: by induction on derivation of - ~~> -, splitting cases on
last step.

- P = p:send(q,v).

  This follows from (1): let T be a trace of the input program ending in skip.
  Then by repeated applications of (1), move p:send(q,v) to the left. Finally,
  the reachable states of <⊥,[[Γ]],Δ;p:send(q,v);E> are the same as
  <⊥,[[Γ[(p,q):=Γ(p,q)·v]]],Δ;E> since Δ only contains assignments.

- P = q: x:=recvFrom(p).

  The conclusion follows from the fact(2) that 'recvFrom(p)'
  is a left mover (when enabled), following the same reasoning as above.

- P = q: x:=recvFrom(*);A || B

  By IH,
   ∀ σ,μ,P0,P1,P0',Q,Q',E,
      (q: x:=recvFrom(*);A | B) ≡ P0;P1 | Q 
   => (q: x:=recvFrom(p);A | B) ≡ P0';P1 | Q'
   => Δ;(E | (P0;P1 | Q) | [[Ψ]]) : race-free   -
   => (     <⊥, [[Γ]], Δ;(E | P0;P1 | Q | [[Ψ]])>      --->* <σ,μ,skip>
        <-> <⊥, [[Γ']], Δ';(E | P0';P1 | Q' | [[Ψ']])> --->* <σ,μ,skip> ).

  Assume for some σ0,μ0,E0,
  
   (b) Δ;(E | x:=recvFrom(*);A | B | [[Ψ]]) : race-free 
   (c) <⊥, [[Γ]], Δ;(E | x:=recvFrom(*);A | B | [[Ψ]])>     --->* <σ0,μ0,skip>

   We need to show:
   <⊥, [[Γ']], Δ';(E | A' | B' | [[Ψ']])> --->* <σ0,μ0,skip>.

  By (b), either there exists a process p such that x is only assigned
  messages sent by x or there is a set of processes P all running the
  program S such that x is only assigned messages sent from a single
  location in S.

  Thus,

  ∃p0:proc.
    [[(E | x:= recvFrom(*) | A | B | [[Ψ]])]] = [[(E | x := recvFrom(p0) | A | B [[Ψ]]]]
  Or
  ∃P0:procSet.
    [[(E | x:= recvFrom(*) | A | B | [[Ψ]])]] = [[(E | x := recvFrom(P0) | A | B [[Ψ]]]].

  Assume the former case.
  - If p is equal to p0, then the conclusion is obvious since the
    program with recvFrom(p0) is equivalent to the input program
  - If p is not equal to p0, then in Δ;(E | x:=recvFrom(p);A | B), the
    recvFrom(p) will never be enabled. But by the IH,
    Δ;(E | x:=recvFrom(p);A | B | [[Ψ]]) deadlocks iff Δ';(E | A' | B' | [[Ψ']]) deadlocks,
    soit must be the case that the recvFrom(p) was eventually enabled. So p
    must have been equal to p0.
  The reasoning is similar for the latter case.

- P  = P(x)
  P' = P(v)

  Since D |= x = v, and x is never assigned in P, in all executions of
  (E | P(x) | [[Ψ]]) x is equal to v. Thus,
    E | P(x) | [[Ψ]] ≡ E | P(v) | [[Ψ]],
  which proves the goal.

- Context

  By IH
   ∀ σ,μ,P0,P1,P0',Q,Q',E,
      (A  | C)  ≡ P0;P1 | Q 
   => (A' | C') ≡ P0';P1 | Q'
   => Δ;(E | (P0;P1 | Q) | [[Ψ]]) : race-free    
   => (     <⊥, [[Γ]], Δ;(E | P0;P1 | Q | [[Ψ]])>      --->* <σ,μ,skip>
        <-> <⊥, [[Γ']], Δ';(E | P0';P1 | Q' | [[Ψ']])> --->* <σ,μ,skip> ).

  Assume for some σ0,μ0,E0,
  
   (b) Δ;(E0 | A;B | C | [[Ψ]]) : race-free 
   (c) <⊥, [[Γ]], Δ;(E0 | A;B | C | [[Ψ]])>     --->* <σ0,μ0,skip>

  Instantiating the IH with
    (σ:=σ0) (μ:=μ0) (P0:=A) (P0:=A') (P1:=B) (Q:=C) (Q':=C') (E:=E0)
  Give us
      (A;B  | C)  ≡ A;B | C
   => (A';B | C') ≡ A';P1 | C'
   => Δ;(E0 | (A;B | C) | [[Ψ]]) : race-free    
   => (     <⊥, [[Γ]], Δ;(E0 | A;B | C | [[Ψ]])>      --->* <σ,μ,skip>
        <=> <⊥, [[Γ']], Δ';(E0 | A';B | C' | [[Ψ']])> --->* <σ,μ,skip> ).
  Which proves the conclusion.

- P = nondet(p ∈ P, T(p))
  prove:
  ∀ σ,μ,P0,P1,P0',Q,Q',E,
  nondet(p ∈ P, T(p)) ≡ P0;P1 | Q =>
  T(p*)               ≡ P0';P1 | Q' =>
  nondet(p ∈ P, T(p)) : race-free =>
  (   <⊥, [[Γ]], Δ;(E | nondet(p ∈ P, T(p)) | [[Ψ]]> --->* <σ,μ,skip>
  <=> <⊥, [[Γ]], Δ;(E | T(p*)               | [[Ψ]]> --->* <σ,μ,skip>

- P = recvFrom(*)
Assume:
  x := recvFrom(*)|Π(S'): Q,Γ,Δ,Ψ ~>
  x := recvFrom(p)|p*: Q|Π(S\p*): Q,Γ,Δ;p* := * in S,Ψ.

Suppose that
 [[ x := recvFrom(*)|Π(S'): Q|E],Γ,Δ,Ψ]
reaches a DL, and let T be the halting trace.

By assumption (well-tagged programs), for every recv, either
a single concrete sender sends matching messages or one of a
set of processes (S) sends a matching message from a single
syntactic send. Let p* be the sender.

- Case: p* is not in S. But this is not possible, since the first argument
of the send() is equal to `m` (and the program is well-tagged).

- Case: p* is in S \ S'. So p* must be in E. But by hypothesis, if p*: B'
is in E then B' < B. This means that a message sent from p* came from
a location *other* than the send() preceding B, which violates the assumption
that all messages sent from a symmetric set come from a single syntactic send.

- Case: p* is in S'. Then the rewritten program reaches the same halted states
as the input program, as p* ranges over all of the elements of S' and the
recvFrom is a left-mover.
