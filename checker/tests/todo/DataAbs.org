#+TITLE: Data Abstraction

* Simple Protocol

#+BEGIN_SRC
p0:
  send p1 0

p1:
  do r :: Int <- recv
     if (r = 0) then (return ()) else (fail)
#+END_SRC

* Using Data Abstraction

** Pred data type

#+BEGIN_SRC
data PredValue       = 0 | 1 | 2 (for unknown predicates)

data MConstr = MTApp  { tycon :: MTyCon, typreds :: [PredValue] }
             | MCaseL Label MConstr
             | MCaseR Label MConstr
             | MTProd { proj1 :: MConstr, proj2 :: MConstr }
             deriving (Ord, Eq, Read, Show, Typeable, Data)

data UnknownVal = UV String

data Pred = Pred {
  predOp    :: Op (=, ≠, >, ≯, <, ≮, ...),
  predConst :: Int | Boolean | String | Pid | ... | UnknownVal
}
#+END_SRC

** Cubes and strongest predicate

A /cube/ over V is a conjunction c_{i1} ∧ c_{i2} ∧ ... ∧ c_{ik} where
- E = {φ_{1}, φ_{2}, ...,  φ_{n}} is the global predicate list
- V = {b_{1}, b_{2}, ..., b_{n}} where boolean variable b_{i} represents the predicate φ_{i} ∈ E,
  - We use ε to represent this relationship: ε(b_{i}) = φ_{i}, ε(¬ b_{i}) = ¬ φ_{i}
  - ε is also extended to cubes and disjunction of cubes. For example:
    - ε(b_{1} ∧ ¬ b_{2}) = φ_{1} ∧ ¬ φ_{2}
    - ε((b_{1} ∧ ¬ b_{2}) ∨ (¬ b_{1} ∧ b_{2})) = (φ_{1} ∧ ¬ φ_{2}) ∨ (¬ φ_{1} ∧ φ_{2})
- c_{ij} ∈ { b_{ij}, ¬ b_{ij} } for some b_{ij} ∈ V.

Now, define G_{V}(φ) where
- φ is a predicate (e.g. coming from the if condition)
such that
- ε(G_{V}(φ)) represents the strongest predicate over ε(V) that *is implied by φ*.

** Predicate selection

- G_{V} : Boolean Exp. → Pred × Boolean
- where Pred ∈ E

The function G_{V} takes a boolean expression (/cond/) and returns the subset of the predicates
that can /cond/ implies and their corresponding value.

*** Base cases:
- G_{V}(true)  = SSkip
- G_{V}(false) = SAssume [] []
- If none of the φ_{i} ∈ E can be implied by φ, then G_{V}(φ) = SSkip

*** Disjunction:
- IF   G_{V}(cond_{1}) = s_{1}
- AND  G_{V}(cond_{2}) = s_{2}
- THEN G_{V}(cond_{1} ∨ cond_{2}) = SNonDet [s_{1}, s_{2}]

*** Conjunction:
- IF   G_{V}(cond_{1}) = SAssume [P_{11}, P_{12}, ...] [V_{11}, V_{12}, ...]
- AND  G_{V}(cond_{2}) = SAssume [P_{21}, P_{22}, ...] [V_{21}, V_{22}, ...]
- THEN G_{V}(cond_{1} ∧ cond_{2}) = SAssume [P_{11}, P_{12}, ..., P_{21}, P_{22}, ...]
                                         [V_{11}, V_{12}, ..., V_{21}, V_{22}, ...]
*NOTE:*
- IF   ∃j,k . P_{1j} = P_{2k} ∧ V_{1j} ≠ V_{2k}
- THEN since cond_{1} ∧ cond_{2} = false, G_{V}(cond_{1} ∧ cond_{2}) = SAssume [] []

** New statement type

#+BEGIN_SRC
data Stmt a = ...
            | SAssume { msgValue     :: [PredValue]
                      , assumedValue :: [Boolean]
                      , annot        :: a
                      }
#+END_SRC

translates (roughly) into

#+BEGIN_SRC
def assume([], []) =
  while (true)

def assume([p1,p2,...,pn], [v1,v2,...,vn]) =
  while ( (p1 != 2 && p1 != v1)   ||
          (p2 != 2 && p2 != v2)   ||
          ...                     ||
          (pn != 2 && pn != vn));
#+END_SRC

** Current Approach

#+BEGIN_SRC
old_config = Config {
  cTypes  = fromList [(0, fromList [(0,MTApp (MTyCon "Int") [])])],
  cSets   = [],
  cUnfold = [],
  cProcs  = [(PConc 0, SSkip ()),
             (PConc 1, SBlock [
                         SRecv (0,0, MTApp (MTyCon "Int") []) (),
                         SNonDet [SSkip (), SDie ()] ()
                       ] ()),
             (PConc 5, SSend (PConc 1) (0,0,MTApp (MTyCon "Int") []) ())
            ]
  }
#+END_SRC

** Proposed IL code for this protocol

#+BEGIN_SRC
new_config = Config {
  cPreds  = [v > 0, v = 0]                                                  -- generate this somehow :)
  cTypes  = fromList [(0, fromList [(0,MTApp (MTyCon "Int") [0,1])])],
  cSets   = [],
  cUnfold = [],
  cProcs  = [(PConc 0, SSkip ()),
             (PConc 1, SBlock [
                         SRecv (0,0, MTApp (MTyCon "Int") [P1,P2]) (),      -- let SPIN figure out P1 and P2
                                                                            -- P1 corresponds to v > 0
                                                                            -- P2 corresponds to v = 0
                         SNonDet [SBlock [SAssume [P1,P2] [0,1] (),         -- generate this statement using G_{V}(n = 0)
                                          SSkip ()],
                                  SBlock [SAssume [P2] [0] (),              -- generate this statement using G_{V}(n != 0)
                                          SDie  ()]] ()
                       ] ()),
             (PConc 5, SSend (PConc 1) (0,0,MTApp (MTyCon "Int") [0,1]) ()) -- send [0,1] as well to process 1
            ]
  }
#+END_SRC

** Remaining issues

- How to extract the global predicate list E
- Conversion from a DSL expression (e.g. ~eq n (int 0)~) to the corresponding
  boolean expression (BE) (e.g. n > 0)
- Implementation of G_{V}
- Mapping between variables (that recv returns) and corresponding MConstr's (VarMap : Var → MConstr)
