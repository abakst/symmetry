# Language

statements:
s ::= send(e1,e2)      -- send e2 to e1
    | x := recvFrom(*) -- recv message from any process, bind to x
    | x := recvFrom(p) -- recv message from the pid p, bind to x
    | for (i : I): s   -- iteration over collection
    | while (e): s     -- iteration
    | s;s              -- sequence
    | s + s            -- nondet choice

proc ::= p: s          -- process p runs s

process-soup:
P ::= proc        -- single process
    | Π(p:S) proc -- parallel composition of elements of S
    | (P || P)    -- parallel composition

# Rewrite Rules

## Basic

send:
q is a constant
------------------------------------------------------------
p: send(q,v); G[(p,q) := M],D,X ~~> skip,G[(p,q) := M·v],D,X

recvFrom: 
p is a constant
------------------------------------------------------------
q: x:=recvFrom(p), G[(p,q) := v·M],D,X
~~> skip,G[(p,q) := M],(D;x:=v),X

const:
D |= x = c, c is a constant
----------------------------
P(x),G,D,X ~~> P(c),G,D,X

compose-seq:
A,G,D,X ~> A',G',D',X'
--------------------------
A;B,G,D,X ~> A';B,G',D',X'

compose-par:
A,G,D,X ~~> A',G',D',X'
--------------------------
A||C,G,D,X ~~> A'||C,G,D,X'

## Loops

For:
p* fresh
P* fresh
G' = G ∪ "0 ⊂ P* ⊆ P" ∪ "p* ∈ P*"
A(p*) || Π(p:P*): B(p),G',D,X
~~> skip || Π(p:P*\{q}): B(p) || C(q),G',D;D'(q),X'[q:=T(q)]
------------------------------------------------------------
for (p:P): A(p) || Π(p:P) B(p),G,D,X
~~> Π(p:P) C(p),G,D;for(p:P): C(p),X'[P := Π(p:P) T(p)]

While-exit:
D  |= e
D' |= ¬e
A||B,G,D,X ~~> skip||C,G,D',X'
------------------------------------
while (e) A || B,G,D,X ~~> C,G,D',X'

While-continue:
D  |= e
D' |= e
C < B
A || B,G,D,X ~~> skip || C,G,D',X'
----------------------------------------------------
while (e): A || B,G,D,X ~~> while(e): A || C,G,D',X'

Iter-repeat:
p:A||q:B,G,D,X ~~> skip||q:B,G,(D;D'),X'[p:=Tp][q:=Tq]
----------------------------------------------------
p:for (i:I): A || q:B,G,D,X
~~> q:B,G,D;for(i:I): D',X'[p:=for(i:I) Tp][q:=for(i:I):Tq]

Iter-match:
p:A||q:B,G,D,X ~~> skip,(D;D'),X'[p := Tp][q := Tq]
----------------------------------------------------
p:for (i:I): A || q:for(i:I): B,G,D,X
~~> skip,G,(D;for (i:I) D'),X'[p := for(i:I): Tp][q := for(i:I): Tq]


## Unfolding

sym-repeat:
A || Π(p:P): B(p),G,D,X
~~> skip || B(p*) || Π(p:P\{p*}),G,(D;D'(p*)),X'[p*:=T(p*)]
-----------------------------------------------------------
A || Π(p:P): B(p),G,D,X
~~> Π(p:P),G,(D;p:=*;D'),X'[q:=(p:=*; T(p))]

unfold-send:
G ⊢ p* ∈ P
------------------------------------------
m:send(p*,e) || Π(p:P) B(p),G,D,X
~~> m:send(p*,e)||B(p*)||Π(p:P\{p*}),G,D,X

unfold-recv:
p* fresh
G ⊢ ∅ ⊂ P' ⊆ P
------------------------------------------
m: x := recvFrom(*) || Π(p:P')send(m,v)B(p),G,D,X
~~> m: x := recvFrom(p*) || B(p*) || Π(p:P'\{p*})send(m,v);B(p),G,D;p*:=*;x:=v,X

## Ext

Ext:
p: send(x,y),G,D,X[p := T] ~~> skip,G,D,X[p := T;send(x,y)]

Compose-External:
B || Π(...) X',G,D,X ~~> skip,G,(D;D''),X''
A,G,D,X ~~> C,G,(D;D'),X'
------------------------------------------------
A||B,G,D,X ~~> C,G,(D;D' ∪ D''),X''

# Soundness Proof

## Main Theorem

Thm:
 If Γ,Δ,Ψ,P ~~> Γ',Δ',Ψ',P' then,
   ∀ E, (such that (1)wf...& (2)small...)
   If <[[Γ]], Δ;(E | P | [[Ψ]])> ---> DL, then
      <[[Γ']], Δ';(E | P' | [[Ψ]])> ---> DL.

 Where [[Γ]] = "message buffers in Γ"
       [[Ψ]] = "parallel composition of domain of Ψ"
       (1) E is well formed with Γ ==> should not duplicate any
                existing processes in P...
       (2) "small" meaning that for a sym set S, if
           p:A is in P, p and p' ∈ S, p':A' ∈ E,
           then A' < A (i.e. syntactically smaller, reduced...)

 Additional assumptions:
   -P is well-tagged (all recvs tagged either from a single loc in a symmetric set, or
    from a single concrete proc)

## Proof

Proof: by induction on derivation of - ~~> -, splitting cases on
last step.

- P = recv.
By the form of the rule,

Γ[(p,q) := m:M],Δ,Ψ,x := recvFrom(p) ~> Γ,Δ;x := m,Ψ,skip.

Let E s.t.
  < [[ Γ[(p,q) := m:M] ]],Δ;E | Ψ |x := recvFrom(p) > ~A~> DL
To show:
  < [[ Γ ]],Δ;x := m;E | Ψ |skip > ~B~> DL

The prefix of A must be all of Δ (single thread). In the remainder, E
| Ψ |x := recvFrom(p), recvFrom(p) is a left mover (by lemma
recvs-are-left-movers). So any halted state reachable must also be
reachable from the state after immediately executing the recvFrom,
which gives us the program we wish to show.

- P = send.
Two possible rules: send: 
Same reasoning as recv (send is always a left mover).
Ext:
Assume [[ Γ ]], Δ;([[Ψ[p:=T]]] | p:send(q,m) | E ~T~> DL.

- P = parallel compose.
Assume:
 Γ,Δ,Ψ,P ~> Γ',Δ',Ψ',P' and
 [[ Γ,Δ,Ψ,P ]] < [[ Γ',Δ',Ψ',P' ]]. Then
 ∀ E,
   < [[ Γ ]], Δ;(Ψ | P | E) > ~~> DL implies
   < [[ Γ' ]], Δ',(Ψ' | P' | E) >.
We need to show that
 ∀ E,
   < [[ Γ ]], Δ;(Ψ | P | A | E) > ~~> DL implies
   < [[ Γ' ]], Δ',(Ψ' | P' | A | E) >

 which follows by instantiating the IH with (E := E | A).

- P = transitive
Assume:

 Γ,Δ,Ψ,P ~> Γ',Δ',Ψ',P' and
 Γ',Δ',Ψ',P' ~> Γ'',Δ'',Ψ'',P'' and
 [[ Γ,Δ,Ψ,P ]] < [[ Γ'',Δ'',Ψ'',P'' ]].

- P = recvFrom(S)
Assume:
 Γ,Δ,Ψ,x := recvFrom(*)|Π(S'): Q ~>
  Γ,Δ;p* := * in S,Ψ,x := recvFrom(p)|p*: Q|Π(S\p*): Q.

Suppose that
 [[ Γ,Δ,Ψ,x := recvFrom(*)|Π(S'): Q|E]]
reaches a DL, and let T be the halting trace.

By assumption (well-tagged programs), for every recv, either
a single concrete sender sends matching messages or one of a
set of processes (S) sends a matching message from a single
syntactic send. Let p* be the sender.

- Case: p* is not in S. But this is not possible, since the first argument
of the send() is equal to `m` (and the program is well-tagged).

- Case: p* is in S \ S'. So p* must be in E. But by hypothesis, if p*: B'
is in E then B' < B. This means that a message sent from p* came from
a location *other* than the send() preceding B, which violates the assumption
that all messages sent from a symmetric set come from a single syntactic send.

- Case: p* is in S'. Then the rewritten program reaches the same halted states
as the input program, as p* ranges over all of the elements of S' and the
recvFrom is a left-mover.
