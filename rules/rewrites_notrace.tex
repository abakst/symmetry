\documentclass{article}

\usepackage{framed}
\usepackage{fullpage}
\usepackage{xspace}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathpartir}
\usepackage{mathtools}

\newcommand{\setcard}[1]{\left\vert{#1}\right\vert}

\newcommand{\inferrewrite}[2]{\ensuremath{\inferrule{#1}{#2}}}
\newcommand{\rewrite}[6]{#1,#2,#3 \mathrel{\longrightarrow} #4,#5,#6}
\newcommand{\rewriteinv}[4]{#1,#2,#3 \vdash #4}
\newcommand{\mover}[2]{{#1}\,:\,\mathbb{#2}\xspace}
\newcommand{\parpipe}{\mathrel{\parallel}}
\newcommand{\for}[3]{\mathsf{for} (#1 : #2) \{#3\}}
\newcommand{\while}[2]{\mathsf{while} (#1) \{#2\}}
\newcommand{\parp}[2]{{#1}\parpipe{#2}}
\newcommand{\symm}[3]{\Pi_{{#1 \in #2}}\ #3}

\newcommand{\unfolded}[1]{#1'}
\newcommand{\reduced}[1]{#1_{\bot}}

\newcommand{\fn}[1]{\mathsf{#1}}
\newcommand{\chan}[1]{\fn{chan}(#1)}

\newcommand{\sub}[2]{[#2/#1]}
\newcommand{\emptytrace}{\varepsilon}
\newcommand{\var}[1]{\mathtt{#1}}
\newcommand{\stmt}[2]{#1\,\triangleright\,\mathtt{#2}}
\newcommand{\recv}[2]{\stmt{#1}{#2 := recv}()}
\newcommand{\send}[3]{\stmt{#1}{send}(#2,#3)}
\newcommand{\assert}[1]{\mathtt{assert}\;#1}
\newcommand{\fold}[2]{#2 \leftarrow #2 \uplus \{#1\}} %%{\fn{fold}(#1,#2)}
\newcommand{\unfold}[2]{#2 \leftarrow #2 \setminus \{#1\}}

\newcommand{\ctx}{\Gamma}
\newcommand{\trace}{\Delta}
\newcommand{\abs}[1]{\alpha(#1)}
\begin{document}

\newif\ifconc
\conctrue
%%\concfalse

\begin{framed}
\textsc{Primitive Operations}
\[
\inferrule[Send]{
  \ifconc
    \trace \vDash p 
  \else
    \trace \vdash p = j
  \fi
}{
  \rewrite{\ctx}
          {\ifconc \trace \else \trace \fi}
          {\send{i}{p}{m}}
          {\ctx[(i,j)\mapsto\ctx(i,j) \cdot m]}
          {\ifconc \trace\ \else \trace \fi}
          {\emptytrace}
}
\]

\[
\inferrule[Receive]{
  \ctx(i,j) = \mathtt{m} \cdot M
}{
  \rewrite{\ctx}
          {\ifconc \trace \else \trace \fi}
          {\recv{j}{x}}
          {\ctx[(i,j)\mapsto M]}
          {\ifconc \trace \else 
            \trace \uplus \{\mathtt{x} \mapsto \mathtt{m}\}
           \fi}
          {\emptytrace}
}
\]

\[
\inferrule[Unfold]{
  \trace \vDash \unfolded{i} \in I
}{
  \rewrite{\ctx}{\trace}
          {\symm{i}{I}{P(i)}}
          {\ctx}{\trace;\unfold{\unfolded{i}}{I}}
          {\parp{P(\unfolded{i})}{\symm{i}{I}{P(i)}}}
}
\]

\[
\inferrule[Fold]{
  \forall{i \in I},\,
    \trace \vDash \var{x}_i = \var{x}_{\unfolded{i}}
}{
  \rewrite{\ctx}
          {\trace}
          {\parp{P(\unfolded{i})}{\symm{i}{I}{P(i)}}}
          {\ctx}
          {\trace;\fold{\unfolded{i}}{I}}
          {\symm{i}{I}{P(i)}}
}
\]
\end{framed}

\begin{framed}
\textsc{Structural Rules}
\[
  \inferrule[Prefix] {
    \rewrite{\ctx}
            {\trace}
            {\cdots \parpipe P_i \parpipe \cdots}
            {\ctx'}
            {\trace'}
            {\cdots \parpipe Q_i \parpipe \cdots}
  }{
    \rewrite{\ctx}
            {\trace}
            {\cdots \parpipe P_i;R_i \parpipe \cdots}
            {\ctx'}
            {\trace'}
            {\cdots \parpipe Q_i;R_i \parpipe \cdots}
  }
\]

% \[
%   \inferrule[Symm-Prefix???]{
%     \rewrite{\ctx}
%             {\trace}
%             {\parp{P(\unfolded{i});Q(\unfolded{i})}{P(\reduced{i});Q(\reduced{i})}}
%             {\ctx}
%             {\trace'}
%             {(\parp{P(\unfolded{i})}{P(\reduced{i})});
%              (\parp{Q(\unfolded{i})}{Q(\reduced{i})})}
%   }{
%     \rewrite{\ctx}
%             {\trace}
%             {\symm{i}{I}{P(i);Q(i)}}
%             {\ctx}
%             {\trace'}
%             {\symm{i}{I}{P(i)};\symm{i}{I}{Q(i)}}
%   }
% \]
\[
  \inferrule[Framing] {
    \rewrite{\ctx}
            {\trace}
            {P}
            {\ctx'}
            {\trace'}
            {Q}
  }{
    \rewrite{\ctx}
            {\trace}
            {\parp{P}{R}}
            {\ctx'}
            {\trace'}
            {\parp{Q}{R}}
  }
% \]
% \quad
% \[
  % \inferrule[Consequence] {
  %   \rewrite{\ctx}{\trace}{P}{\ctx'}{P'}\\
  %   \rewrite{\ctx'}{P'}{S'}{\ctx''}{P''}
  % }{
  %   \rewrite{\ctx}{P}{S;S'}{\ctx''}{P''}
  % }
% \]
% \quad
% \[
% \inferrule[Push Trace]{
% \rewrite{\ctx}{P}{S}{\ctx'}{Q}
% }{
% \rewrite{\ctx}{P}{\emptytrace}{\ctx}{S;Q}
% }
\]
\[
\inferrule[While-Continue]
{}
{\rewrite{\ctx}{\trace}{\while{B}{P}}
         {\ctx}{\trace}{\assert{B};P;\while{B}{P}}}
\]

\[
\inferrule[While-Exit]
{}
{\rewrite{\ctx}{\trace}{\while{B}{P}}
         {\ctx}{\trace}{\assert{B};P;\assert{\neg{B}}}}
\]
\end{framed}

\begin{framed}
\noindent\textsc{Iteration}

\[
  \inferrule[Invariant]
  {
    \unfolded{i},\, I',\, \textit{fresh}\\
    I' \subseteq I\\
    \\\\
    % \psi \equiv \varphi(I',J') \wedge \unfolded{i} \in I \wedge \unfolded{i} \notin I'\\
    % \trace \vDash \varphi(\emptyset,\emptyset)\\
    % \trace;\trace' \vDash \psi \Rightarrow \varphi(I'\cup\{\unfolded{i}\},J'\cup{J_\delta})\\
    % \rewrite{\ctx}{\trace}
    %         {\parp{P(\unfolded{i})}
    %               {\symm{j}{J}{Q(j)}}}
    %         {\ctx}{\trace'(\unfolded{i})}
    %         {\parp{\emptytrace}
    %           {\parp{\symm{j}{J\setminus{J'}}{Q(j)}}
    %             {\symm{j}{J'}{Q'(j)}}}}\\
    \rewrite{\ctx}{\trace;\for{i}{I'}{\trace'(i)}}
            {\parp{P(\unfolded{i})}
                  {\parp{\symm{j}{J}{Q(j)}}
                        {\symm{j}{J'}{Q'(j)}}}}
            {\ctx}{\trace'(\unfolded{i})}
            {\parp{\emptytrace}
              {\parp{\symm{j}{J}{Q(j)}}
                {\symm{j}{J'}{Q'(j)}}}}\\
  }
  {
  \rewriteinv{\ctx}
             {\trace}
          {\parp{\for{i}{I}{P(i)}}
                {\parp{\symm{j}{J}{Q(j)}}
                  {\symm{j}{J'}{Q'(j)}}}}
          {\trace'(i)}
  }
\]
\[
\inferrule[Update-Collection]
{
  \rewriteinv{\ctx}
          {\trace}
          {\parp{\for{i}{I}{P(i)}}
                {\symm{j}{J}{Q(j);Q'(j)}}}
          {\trace'(i)}\\
}
{
  \rewrite{\ctx}{\trace}
          {\parp{\for{i}{I}{P(i)}}
                {\symm{j}{J}{Q(j)}}}
          {\ctx}{\trace;\for{i}{I}{\trace'(i)}}
          {\parp{\emptytrace}{\parp{\symm{i}{J}{Q(j)}}
                                   {\symm{i}{J'}{Q'(j)}}}}
}
\]
\iffalse
\[
\inferrule[Strong-Update]
{
  \unfolded{i} \textit{fresh}\\
  \rewrite{\ctx}{\trace}{\parp{P(\unfolded{i})}{Q(\unfolded{i})}}
          {\ctx}{\ifconc \trace;\trace' \else \trace \uplus \trace' \fi}{\emptytrace}
}
{
 \rewrite{\ctx}
         {\trace}
         {\parp{\for{i}{I}{P(i)}}
               {\symm{i}{I}{Q(i)}}}
         {\ctx}
         {\ifconc \trace;\for{i}{I}{\sub{\trace'}{\unfolded{i}}{i}} \else 
           \trace
           \fi
         }
         {\emptytrace}
}
\]

\[
\inferrule[Weak-Update]
{
  \unfolded{i} \textit{fresh}\\
  \rewrite{\ctx}
          {\trace}
          {\parp{P(\unfolded{i})}{Q}}
          {\ctx}
          {\ifconc \trace;\trace' \else \trace \uplus \trace' \fi}
          {\parp{\emptytrace}{Q}}\\
          \ifconc
          \else
          \trace'' = \{ x(i) \mapsto c \mid x_{\unfolded{i}} \mapsto c \in \trace'
          \fi
}
{
 \rewrite{\ctx}
         {\trace}
         {\parp{\for{i}{I}{P(i)}}
               {\symm{j}{J}{Q(j)}}}
         {\ctx}
         {\ifconc \trace;\for{i}{I}{\sub{\trace'}{\unfolded{i}}{i}} \else
          \trace \uplus \trace''
          \fi}
         {\emptytrace}
}
\]
\fi
\end{framed}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main.tex"
%%% End:
