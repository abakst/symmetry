* Definitions

- Process ID    : PId
- Var Type      : TId
- Message Type  : T = TId × CId × Value
- Message       : M_{i} = P × T
- Message Queue : Q_{i} ⊆ (M_{i})*
- Local Vars    : X_{i} = Var → Value
- Process State : C_{i} = Q_{i} × X_{i} × S_{i}
- General State : C   ⊆ C_{1} × C_{1} × ... × C_{n}

- x ∈ Var   → x : Expr
- x ∈ Value → x : Expr
- x : Expr  → L x : Expr
- x : Expr  → R x : Expr

* Actions

- state before action : c  = (Q_{1},  X_{1},  S_{1},  ..., Q_{n},  X_{n},  S_{n})
- state after action  : c' = (Q_{1}', X_{1}', S_{1}', ..., Q_{n}', X_{n}', S_{n}')

** SSend Pid [(TId, [(CId, MConstr)], Stmt a)] a

S_{j} = SSend p [..., (t_{k}, [..., (con_{kl}, v_{kl}), ...], S_{jk}), ...]

IF   ∃k,l such that
- Q_{p}' = Q_{p} . (j, (t_{k}, con_{kl}, v_{kl}))
- ∀i≠j : Q_{i}' = Q_{i}
- S_{j}' = S_{jk}
- ∀i≠j : S_{i}' = S_{i}
- ∀i   : X_{i}' = X_{i}

THEN c → c'

** SRecv [(TId, [(CId, MConstr)], Stmt a)] a

S_j = SRecv [..., (t_k, [..., (con_{kl}, var_{kl}), ...], S_{jk}), ...]

IF   ∃p,k,l such that
- ∃val,θ such that
  - Q_{j}  = (p, (t_{k}, con_{kl}, val)) . Q_{j}' ∧
  - θ(var_{kl}) = val ∧
  - X_{j}' = X_{j} ∪ {var_{kl} → val}
- ∀i≠j : Q_{i}' = Q_{i}
- S_{j}' = S_{jk}
- ∀i≠j : S_{i}' = S_{i}
- ∀i≠j : X_{i}' = X_{i}

THEN c → c'

** TODO SCase Var (Stmt a) (Stmt a) a

** TODO SIter Var Set (Stmt a) a

** TODO SLoop LVar (Stmt a) a

** TODO SChoose Var Set (Stmt a) a

** TODO SVar LVar a

** TODO SDie a

** TODO SBlock [Stmt a] a

** TODO SSkip a
